-- Place this module (LocalScript) replacement in the same location as your original script
return function(newParent)
	local function init()
		task.wait()

		-- Services
		local UserInputService = game:GetService("UserInputService")
		local Players = game:GetService("Players")
		local ReplicatedStorage = game:GetService("ReplicatedStorage")
		local TweenService = game:GetService("TweenService")
		local Camera = workspace.CurrentCamera

		-- Locals
		local LocalPlayer = Players.LocalPlayer
		local PlayerGui = LocalPlayer and LocalPlayer:WaitForChild("PlayerGui")
		local Tool = newParent
		local Remotes = Tool:WaitForChild("Remotes")
		local BuildPreview = workspace:WaitForChild("BuildReplicatorPart")

		local EquippedRemote = Remotes:FindFirstChild("Equipped")
		local PlaceRemote = Remotes:FindFirstChild("Place")
		local DestroyRemote = Remotes:FindFirstChild("DestroyItemRemote")
		local PlaceBuildRemoveEvent = ReplicatedStorage:FindFirstChild("PlaceBuildRemoveItemEvent")

		local BuildsFolder = ReplicatedStorage:FindFirstChild("Builds")
		local BuildModel = nil
		if BuildsFolder then
			BuildModel = BuildsFolder:FindFirstChild(Tool.Name)
		end

		-- UI references (use WaitForChild where appropriate)
		local InventorySystem = PlayerGui and PlayerGui:FindFirstChild("TheInventorySystem")
		local XYZGui = PlayerGui and PlayerGui:FindFirstChild("XYZ")
		local XButton, YButton, ZButton, Checkmark
		if XYZGui then
			XButton = XYZGui:FindFirstChild("X")
			YButton = XYZGui:FindFirstChild("Y")
			ZButton = XYZGui:FindFirstChild("Z")
			Checkmark = XYZGui:FindFirstChild("CheckmarkGUI")
		end

		local MobileUI = PlayerGui and PlayerGui:FindFirstChild("MobileButtons")
		local RotateUI, RotateButton, ForwardUI, ForwardButton, BackwardUI, BackwardButton
		if MobileUI then
			RotateUI = MobileUI:FindFirstChild("Rotate")
			RotateButton = RotateUI and RotateUI:FindFirstChild("RotateButton")
			ForwardUI = MobileUI:FindFirstChild("MoveForward")
			ForwardButton = ForwardUI and ForwardUI:FindFirstChild("ForwardButton")
			BackwardUI = MobileUI:FindFirstChild("MoveBackward")
			BackwardButton = BackwardUI and BackwardUI:FindFirstChild("BackwardButton")
		end

		local PlaceSound = Tool:FindFirstChild("PlaceSound")

		-- State
		local isEquipped = false
		local movingForward = false
		local movingBackward = false
		local axisX, axisY, axisZ = true, false, false
		local canRotate = true
		local isRotating = false
		local buildDistance = 8.25
		local rotation = Vector3.new(0,0,0)
		local ableToPlace = false
		local lastAbleState = nil

		-- Mobile button size
		local buttonSize = 120
		if RotateButton and RotateButton:IsA("Frame") and RotateButton:FindFirstChild("Screen") then
			local abs = RotateButton.Screen.AbsoluteSize
			if math.min(abs.X, abs.Y) > 500 then
				buttonSize = 70
			else
				buttonSize = 120
			end
		end

		local function setupMobileUI()
			if UserInputService.TouchEnabled and RotateUI and ForwardUI and BackwardUI and RotateButton and ForwardButton and BackwardButton then
				RotateUI.Enabled = true
				RotateButton.Size = UDim2.new(0, buttonSize, 0, buttonSize)
				ForwardUI.Enabled = true
				ForwardButton.Size = UDim2.new(0, buttonSize, 0, buttonSize)
				BackwardUI.Enabled = true
				BackwardButton.Size = UDim2.new(0, buttonSize, 0, buttonSize)
			end
		end

		local function setAxis(x, y, z, xImg, yImg, zImg)
			axisX, axisY, axisZ = x, y, z
			if XButton then XButton.Image = xImg end
			if YButton then YButton.Image = yImg end
			if ZButton then ZButton.Image = zImg end
			print("DEBUG: setAxis ->", axisX, axisY, axisZ)
		end

		-- Input listeners
		UserInputService.InputBegan:Connect(function(input)
			if not isEquipped then return end
			if input.KeyCode == Enum.KeyCode.V then
				movingForward = true
				print("DEBUG: input began - V (forward)")
			elseif input.KeyCode == Enum.KeyCode.B then
				movingBackward = true
				print("DEBUG: input began - B (backward)")
			elseif input.KeyCode == Enum.KeyCode.X then
				setAxis(true, false, false, "rbxassetid://16562623753", "rbxassetid://16562604900", "rbxassetid://16562606076")
			elseif input.KeyCode == Enum.KeyCode.Y then
				setAxis(false, true, false, "rbxassetid://16562628313", "rbxassetid://16562630011", "rbxassetid://16562606076")
			elseif input.KeyCode == Enum.KeyCode.Z then
				setAxis(false, false, true, "rbxassetid://16562628313", "rbxassetid://16562604900", "rbxassetid://16562632722")
			elseif input.KeyCode == Enum.KeyCode.R and canRotate then
				isRotating, canRotate = true, false
				print("DEBUG: rotation started (keyboard)")
				-- apply an immediate rotation step
				if axisX then rotation = rotation + Vector3.new(45,0,0)
				elseif axisY then rotation = rotation + Vector3.new(0,45,0)
				elseif axisZ then rotation = rotation + Vector3.new(0,0,45) end
				task.spawn(function()
					task.wait(0.25)
					while isRotating do
						if axisX then rotation = rotation + Vector3.new(45,0,0)
						elseif axisY then rotation = rotation + Vector3.new(0,45,0)
						elseif axisZ then rotation = rotation + Vector3.new(0,0,45) end
						print("DEBUG: rotation updated ->", rotation)
						task.wait(0.25)
					end
					canRotate = true
					print("DEBUG: rotation loop ended")
				end)
			end
		end)

		UserInputService.InputEnded:Connect(function(input)
			if not isEquipped then return end
			if input.KeyCode == Enum.KeyCode.V then
				movingForward = false
				print("DEBUG: input ended - V (forward)")
			elseif input.KeyCode == Enum.KeyCode.B then
				movingBackward = false
				print("DEBUG: input ended - B (backward)")
			elseif input.KeyCode == Enum.KeyCode.R then
				isRotating = false
				print("DEBUG: input ended - R (stop rotate)")
			end
		end)

		-- Mobile UI event bindings (if present)
		if ForwardButton then
			ForwardButton.MouseButton1Down:Connect(function() if isEquipped then movingForward = true; print("DEBUG: ForwardButton down") end end)
			ForwardButton.MouseButton1Up:Connect(function() if isEquipped then movingForward = false; print("DEBUG: ForwardButton up") end end)
		end
		if BackwardButton then
			BackwardButton.MouseButton1Down:Connect(function() if isEquipped then movingBackward = true; print("DEBUG: BackwardButton down") end end)
			BackwardButton.MouseButton1Up:Connect(function() if isEquipped then movingBackward = false; print("DEBUG: BackwardButton up") end end)
		end
		if RotateButton then
			RotateButton.MouseButton1Down:Connect(function() if isEquipped and canRotate then isRotating, canRotate = true, false; print("DEBUG: RotateButton down") end end)
			RotateButton.MouseButton1Up:Connect(function() if isEquipped then isRotating = false; print("DEBUG: RotateButton up") end end)
		end

		if XButton then XButton.Activated:Connect(function() if isEquipped then setAxis(true, false, false, "rbxassetid://16562623753", "rbxassetid://16562604900", "rbxassetid://16562606076") end end) end
		if YButton then YButton.Activated:Connect(function() if isEquipped then setAxis(false, true, false, "rbxassetid://16562628313", "rbxassetid://16562630011", "rbxassetid://16562606076") end end) end
		if ZButton then ZButton.Activated:Connect(function() if isEquipped then setAxis(false, false, true, "rbxassetid://16562628313", "rbxassetid://16562604900", "rbxassetid://16562632722") end end) end

		-- Debug presence of BuildModel
		if not BuildModel then
			warn("DEBUG: BuildModel not found for tool '" .. tostring(Tool.Name) .. "'. ReplicatedStorage.Builds." .. tostring(Tool.Name) .. " is missing or nil.")
		else
			print("DEBUG: BuildModel found:", BuildModel:GetFullName())
		end

		-- Placement check function
		local function canPlace()
			-- returns true if no collisions, or false and the offending parts
			for _, part in pairs(BuildPreview:GetDescendants()) do
				if part:IsA("BasePart") then
					-- skip special preview parts
					if not (part.Name == "BarrierPart" or part.Name == "Epart" or part.Name == "PrimPart" or part.Name == "OpenPos") then
						if part.Transparency and part.Transparency < 0.95 then
							local ok, hitsOrErr = pcall(function()
								return workspace:GetPartBoundsInBox(part.CFrame, part.Size)
							end)
							if ok and hitsOrErr then
								for _, hit in pairs(hitsOrErr) do
									if hit and hit:IsA("BasePart") then
										-- ignore preview children and player's own character
										if not hit:IsDescendantOf(BuildPreview) and not hit:IsDescendantOf(LocalPlayer.Character) then
											if hit.CanCollide and ((hit.Transparency or 0) < 0.95) then
												return false, part, hit
											end
										end
									end
								end
							else
								-- if GetPartBoundsInBox failed, print error but continue
								print("DEBUG: GetPartBoundsInBox call failed for part", part.Name, "->", tostring(hitsOrErr))
							end
						end
					end
				end
			end
			return true
		end

		-- Equipped behavior
		Tool.Equipped:Connect(function()
			isEquipped = true
			print("DEBUG: Tool equipped:", Tool.Name)
			setupMobileUI()
			if XYZGui then XYZGui.Enabled = true end
			setAxis(true, false, false, "rbxassetid://16562623753", "rbxassetid://16562604900", "rbxassetid://16562606076")

			rotation = Vector3.new(0,0,0)

			-- prepare preview
			BuildPreview:ClearAllChildren()
			BuildPreview.CFrame = Camera.CFrame * CFrame.new(0, 0, -buildDistance) -- in front of camera

			-- clone preview model
			if BuildModel then
				local clonedCount = 0
				for _, src in ipairs(BuildModel:GetDescendants()) do
					if src:IsA("BasePart") then
						local clone = src:Clone()
						clone.Parent = BuildPreview
						clone.CanCollide = false

						-- compute offset safely
						local placed = false
						if BuildModel.PrimaryPart and BuildModel.PrimaryPart:IsA("BasePart") then
							local ok, offset = pcall(function()
								return BuildModel.PrimaryPart.CFrame:ToObjectSpace(src.CFrame)
							end)
							if ok and offset then
								clone.CFrame = BuildPreview.CFrame * offset
								placed = true
							end
						else
							local ok, modelCFrame = pcall(function() return BuildModel:GetModelCFrame() end)
							if ok and modelCFrame then
								local ok2, offset = pcall(function()
									return modelCFrame:ToObjectSpace(src.CFrame)
								end)
								if ok2 and offset then
									clone.CFrame = BuildPreview.CFrame * offset
									placed = true
								end
							end
						end

						-- fallback: world-align (not ideal but safe)
						if not placed then
							print("DEBUG: fallback world-align for preview part", src.Name)
							clone.CFrame = src.CFrame
						end

						-- preview visuals
						if not (src.Name == "BarrierPart" or src.Name == "Epart" or src.Name == "PrimPart" or src.Name == "OpenPos") then
							clone.Transparency = 0.4
						end

						local weld = Instance.new("WeldConstraint")
						weld.Part0 = BuildPreview
						weld.Part1 = clone
						weld.Parent = clone

						pcall(function() clone.CollisionGroup = "Builds" end)
						clonedCount = clonedCount + 1
					end
				end
				print("DEBUG: preview cloned parts:", clonedCount)
			else
				print("DEBUG: no BuildModel, skipped preview cloning.")
			end

			-- reset placement state
			lastAbleState = nil
			ableToPlace = false

			-- preview loop while equipped
			while isEquipped do
				Camera = workspace.CurrentCamera
				local pos = Camera.CFrame.Position
				if movingForward and buildDistance < 12.5 then
					buildDistance = buildDistance + 0.3
				end
				if movingBackward and buildDistance > 4 then
					buildDistance = buildDistance - 0.3
				end

				local targetCFrame = CFrame.new(pos + Camera.CFrame.LookVector * buildDistance) *
					CFrame.fromEulerAnglesXYZ(math.rad(rotation.X), math.rad(rotation.Y), math.rad(rotation.Z))

				local tween = TweenService:Create(BuildPreview, TweenInfo.new(0.25), { CFrame = targetCFrame })
				tween:Play()

				-- placement validity check
				local ok, pPart, hitPart = canPlace()
				ableToPlace = ok and true or false

				if lastAbleState ~= ableToPlace then
					if ableToPlace then
						print("DEBUG: ableToPlace -> TRUE")
						pcall(function()
							if Checkmark and (Checkmark:IsA("ImageLabel") or Checkmark:IsA("ImageButton")) then
								Checkmark.ImageColor3 = Color3.fromRGB(0, 200, 0)
								Checkmark.Visible = true
							end
						end)
					else
						print("DEBUG: ableToPlace -> FALSE", "conflict part:", (pPart and pPart.Name) or "nil", "hit:", (hitPart and hitPart.Name) or "nil")
						pcall(function()
							if Checkmark and (Checkmark:IsA("ImageLabel") or Checkmark:IsA("ImageButton")) then
								Checkmark.ImageColor3 = Color3.fromRGB(200, 0, 0)
								Checkmark.Visible = true
							end
						end)
					end
					lastAbleState = ableToPlace
				end

				task.wait()
			end
		end)

		Tool.Unequipped:Connect(function()
			isEquipped = false
			print("DEBUG: Tool unequipped:", Tool.Name)
			if XYZGui then XYZGui.Enabled = false end
			if RotateUI then RotateUI.Enabled = false end
			if ForwardUI then ForwardUI.Enabled = false end
			if BackwardUI then BackwardUI.Enabled = false end
			BuildPreview:ClearAllChildren()
			pcall(function() if Checkmark then Checkmark.Visible = false end end)
		end)

		-- Activation / placement
		Tool.Activated:Connect(function()
			if not isEquipped then
				print("DEBUG: Activate while not equipped -> ignored")
				return
			end

			print("DEBUG: Activate pressed - ableToPlace:", ableToPlace)
			if not ableToPlace then
				print("DEBUG: placement blocked; not able to place here")
				return
			end

			-- attempt play sound
			if PlaceSound then
				pcall(function() PlaceSound:Play() end)
			end

			-- Fire server safely
			if PlaceRemote and PlaceRemote:IsA("RemoteEvent") then
				local ok, err = pcall(function()
					-- common form: (CFrame, buildName)
					PlaceRemote:FireServer(BuildPreview.CFrame, Tool.Name)
				end)
				print("DEBUG: PlaceRemote:FireServer result:", ok, err and tostring(err) or "no error")
				if not ok then
					-- try alternate payload (table) if initial fails
					local ok2, err2 = pcall(function()
						PlaceRemote:FireServer({ CFrame = BuildPreview.CFrame, BuildName = Tool.Name })
					end)
					print("DEBUG: PlaceRemote alternate payload result:", ok2, err2 and tostring(err2) or "no error")
				end
			else
				warn("DEBUG: PlaceRemote missing or not a RemoteEvent. Can't FireServer.")
			end
		end)
	end

	-- boot
	local function boot()
		init()
	end
	boot()
end
