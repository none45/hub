return function(newParent)
	local function init()
		task.wait()

		local UserInputService = game:GetService("UserInputService")
		local Players = game:GetService("Players")
		local ReplicatedStorage = game:GetService("ReplicatedStorage")
		local TweenService = game:GetService("TweenService")
		local Camera = workspace.CurrentCamera

		local LocalPlayer = Players.LocalPlayer
		local PlayerGui = LocalPlayer.PlayerGui
		local Tool = newParent
		local Remotes = Tool:WaitForChild("Remotes")
		local BuildPreview = workspace:WaitForChild("BuildReplicatorPart")

		local EquippedRemote = Tool.Remotes:WaitForChild("Equipped")
		local PlaceRemote = Remotes:WaitForChild("Place")
		local DestroyRemote = Remotes.DestroyItemRemote
		local PlaceBuildRemoveEvent = ReplicatedStorage:FindFirstChild("PlaceBuildRemoveItemEvent")
		local BuildModel = ReplicatedStorage:FindFirstChild("Builds") and ReplicatedStorage.Builds:FindFirstChild(Tool.Name)

		local InventorySystem = PlayerGui:WaitForChild("TheInventorySystem")
		local HotbarLine = InventorySystem.InventoryMenu["Inventory Section"].Inv.HotbarLine
		local Hotbar = InventorySystem.Hotbar
		local Storage = InventorySystem.InventoryMenu["HomeCore Section"].Storage
		local UnEquipRemote = InventorySystem.UnEquipRemote
		local SlotSelected = InventorySystem.SlotSelected

		local XYZGui = PlayerGui:WaitForChild("XYZ")
		local XButton, YButton, ZButton = XYZGui.X, XYZGui.Y, XYZGui.Z
		local Checkmark = XYZGui:WaitForChild("CheckmarkGUI")

		local MobileUI = LocalPlayer.PlayerGui:WaitForChild("MobileButtons")
		local RotateUI = MobileUI:WaitForChild("Rotate")
		local RotateButton = RotateUI:WaitForChild("RotateButton")
		local ForwardUI = MobileUI:WaitForChild("MoveForward")
		local ForwardButton = ForwardUI:WaitForChild("ForwardButton")
		local BackwardUI = MobileUI:WaitForChild("MoveBackward")
		local BackwardButton = BackwardUI:WaitForChild("BackwardButton")

		local PlaceSound = Tool:FindFirstChild("PlaceSound")

		-- State
		local isEquipped = false
		local movingForward = false
		local movingBackward = false
		local axisX, axisY, axisZ = true, false, false
		local canRotate = true
		local isRotating = false
		local previewCFrame = CFrame.new(Camera.CFrame.Position)
		local buildDistance = 8.25
		local rotation = Vector3.new(0,0,0)

		-- Placement state
		local ableToPlace = false
		local lastAbleState = nil

		-- Setup button sizing for mobile
		local buttonSize = 500
		if math.min(RotateButton.Screen.AbsoluteSize.X, RotateButton.Screen.AbsoluteSize.Y) > 500 then
			buttonSize = 70
		else
			buttonSize = 120
		end

		local function setupMobileUI()
			if UserInputService.TouchEnabled then
				RotateUI.Enabled = true
				RotateButton.Size = UDim2.new(0, buttonSize, 0, buttonSize)
				ForwardUI.Enabled = true
				ForwardButton.Size = UDim2.new(0, buttonSize, 0, buttonSize)
				BackwardUI.Enabled = true
				BackwardButton.Size = UDim2.new(0, buttonSize, 0, buttonSize)
			end
		end

		-- Axis switching
		local function setAxis(x, y, z, xImg, yImg, zImg)
			axisX, axisY, axisZ = x, y, z
			XButton.Image, YButton.Image, ZButton.Image = xImg, yImg, zImg
			print("DEBUG: Axis set to X="..tostring(axisX).." Y="..tostring(axisY).." Z="..tostring(axisZ))
		end

		-- Input listeners
		UserInputService.InputBegan:Connect(function(input)
			if not isEquipped then return end
			if input.KeyCode == Enum.KeyCode.V then
				movingForward = true
				print("DEBUG: Move forward started")
			end
			if input.KeyCode == Enum.KeyCode.B then
				movingBackward = true
				print("DEBUG: Move backward started")
			end
			if input.KeyCode == Enum.KeyCode.X then
				setAxis(true, false, false, "rbxassetid://16562623753", "rbxassetid://16562604900", "rbxassetid://16562606076")
			elseif input.KeyCode == Enum.KeyCode.Y then
				setAxis(false, true, false, "rbxassetid://16562628313", "rbxassetid://16562630011", "rbxassetid://16562606076")
			elseif input.KeyCode == Enum.KeyCode.Z then
				setAxis(false, false, true, "rbxassetid://16562628313", "rbxassetid://16562604900", "rbxassetid://16562632722")
			elseif input.KeyCode == Enum.KeyCode.R and canRotate then
				isRotating, canRotate = true, false
				print("DEBUG: Rotation started (keyboard)")
				if axisX then rotation += Vector3.new(45,0,0)
				elseif axisY then rotation += Vector3.new(0,45,0)
				elseif axisZ then rotation += Vector3.new(0,0,45) end
				task.wait(0.25)
				while isRotating do
					if axisX then rotation += Vector3.new(45,0,0)
					elseif axisY then rotation += Vector3.new(0,45,0)
					elseif axisZ then rotation += Vector3.new(0,0,45) end
					print("DEBUG: rotation changed to", rotation)
					task.wait(0.25)
				end
				canRotate = true
				print("DEBUG: Rotation ended (keyboard)")
			end
		end)

		UserInputService.InputEnded:Connect(function(input)
			if not isEquipped then return end
			if input.KeyCode == Enum.KeyCode.V then
				movingForward = false
				print("DEBUG: Move forward stopped")
			end
			if input.KeyCode == Enum.KeyCode.B then
				movingBackward = false
				print("DEBUG: Move backward stopped")
			end
			if input.KeyCode == Enum.KeyCode.R then
				isRotating = false
				print("DEBUG: Rotation input released")
			end
		end)

		ForwardButton.MouseButton1Down:Connect(function() if isEquipped then movingForward = true; print("DEBUG: Forward button down") end end)
		ForwardButton.MouseButton1Up:Connect(function() if isEquipped then movingForward = false; print("DEBUG: Forward button up") end end)
		BackwardButton.MouseButton1Down:Connect(function() if isEquipped then movingBackward = true; print("DEBUG: Backward button down") end end)
		BackwardButton.MouseButton1Up:Connect(function() if isEquipped then movingBackward = false; print("DEBUG: Backward button up") end end)
		RotateButton.MouseButton1Down:Connect(function() if isEquipped and canRotate then isRotating, canRotate = true, false; print("DEBUG: Rotate button down") end end)
		RotateButton.MouseButton1Up:Connect(function() if isEquipped then isRotating = false; print("DEBUG: Rotate button up") end end)

		XButton.Activated:Connect(function() if isEquipped then setAxis(true, false, false, "rbxassetid://16562623753", "rbxassetid://16562604900", "rbxassetid://16562606076") end end)
		YButton.Activated:Connect(function() if isEquipped then setAxis(false, true, false, "rbxassetid://16562628313", "rbxassetid://16562630011", "rbxassetid://16562606076") end end)
		ZButton.Activated:Connect(function() if isEquipped then setAxis(false, false, true, "rbxassetid://16562628313", "rbxassetid://16562604900", "rbxassetid://16562632722") end end)

		-- Helper: check whether BuildModel exists
		if not BuildModel then
			warn("DEBUG: BuildModel not found for tool '"..tostring(Tool.Name).."'. Placement will likely fail.")
		else
			print("DEBUG: BuildModel found: "..tostring(BuildModel:GetFullName()))
		end

		-- Placement checking function
		local function canPlace()
			-- Check all visible parts in BuildPreview for overlaps with world parts.
			-- Ignore certain preview parts by name and ignore parts that are effectively non-collidable (CanCollide false or very transparent)
			for _, part in pairs(BuildPreview:GetDescendants()) do
				if part:IsA("BasePart") then
					if not (part.Name == "BarrierPart" or part.Name == "Epart" or part.Name == "PrimPart" or part.Name == "OpenPos") then
						if part.Transparency and part.Transparency < 0.95 then
							-- Use GetPartBoundsInBox to find overlapping parts
							local success, hits = pcall(function()
								return workspace:GetPartBoundsInBox(part.CFrame, part.Size)
							end)
							if success and hits then
								for _, hit in pairs(hits) do
									-- ignore the preview/model itself and the player's character
									if not hit:IsDescendantOf(BuildPreview) and not hit:IsDescendantOf(BuildModel) and not hit:IsDescendantOf(LocalPlayer.Character) then
										-- ignore non-collidable or nearly invisible things
										if hit.CanCollide and (hit.Transparency or 0) < 0.95 then
											-- Found a conflicting part
											return false, part, hit
										end
									end
								end
							else
								-- Debug if GetPartBoundsInBox failed for some reason
								-- Continue gracefully rather than blocking placement
								-- (but print debug)
								print("DEBUG: GetPartBoundsInBox failed for part:", part.Name)
							end
						end
					end
				end
			end
			return true
		end

		-- Tool events
		Tool.Equipped:Connect(function()
			isEquipped = true
			print("DEBUG: Tool equipped:", Tool.Name)
			setupMobileUI()
			XYZGui.Enabled = true
			setAxis(true, false, false, "rbxassetid://16562623753", "rbxassetid://16562604900", "rbxassetid://16562606076")

			rotation = Vector3.new(0,0,0)

			-- ensure preview is reset
			BuildPreview:ClearAllChildren()
			BuildPreview.CFrame = CFrame.new(Camera.CFrame.Position + Camera.CFrame.LookVector * buildDistance)

			-- build preview cloning
			if BuildModel then
				local clonedCount = 0
				for _, part in ipairs(BuildModel:GetDescendants()) do
					if part:IsA("MeshPart") or part:IsA("Part") then
						local clone = part:Clone()
						clone.Parent = BuildPreview
						-- Position clones relative to the anchor (BuildPreview). Use part.CFrame relative to model if possible.
						local offset = part.CFrame - BuildModel:GetModelCFrame() and (part.CFrame - BuildModel:GetModelCFrame()) or (CFrame.new(part.Position))
						-- fallback simple approach:
						clone.CFrame = BuildPreview.CFrame * (part.CFrame - BuildModel.PrimaryPart.CFrame)
						-- keep preview aesthetics
						if not (part.Name == "BarrierPart" or part.Name == "Epart" or part.Name == "PrimPart" or part.Name == "OpenPos") then
							clone.Transparency = 0.4
						end
						local weld = Instance.new("WeldConstraint")
						weld.Part0, weld.Part1 = BuildPreview, clone
						weld.Parent = clone
						-- mark preview collision group
						pcall(function() clone.CollisionGroup = "Builds" end)
						clone.CanCollide = false
						clonedCount = clonedCount + 1
					end
				end
				print("DEBUG: Cloned preview parts:", clonedCount)
			else
				print("DEBUG: No BuildModel to clone for preview.")
			end

			-- Reset last state so the check prints once on equip
			lastAbleState = nil
			ableToPlace = false

			while isEquipped do
				Camera = workspace.CurrentCamera
				local pos = Camera.CFrame.Position
				if movingForward and buildDistance < 12.5 then
					buildDistance += 0.3
					-- debug small increments
					--print("DEBUG: buildDistance increased to", buildDistance)
				end
				if movingBackward and buildDistance > 4 then
					buildDistance -= 0.3
					--print("DEBUG: buildDistance decreased to", buildDistance)
				end

				local targetCFrame = CFrame.new(pos + Camera.CFrame.LookVector * buildDistance) *
					CFrame.fromEulerAnglesXYZ(math.rad(rotation.X), math.rad(rotation.Y), math.rad(rotation.Z))

				-- tween preview to target
				local tween = TweenService:Create(BuildPreview, TweenInfo.new(0.25), { CFrame = targetCFrame })
				tween:Play()

				-- placement validity check (once per tick)
				local ok, pPart, hitPart = canPlace()
				ableToPlace = ok and true or false

				-- Only print when the status changes to reduce spam
				if lastAbleState ~= ableToPlace then
					if ableToPlace then
						print("DEBUG: ableToPlace -> TRUE")
						-- update GUI checkmark (green)
						pcall(function()
							if Checkmark:IsA("ImageLabel") or Checkmark:IsA("ImageButton") then
								Checkmark.ImageColor3 = Color3.fromRGB(0, 200, 0)
								Checkmark.Visible = true
							end
						end)
					else
						print("DEBUG: ableToPlace -> FALSE (conflict with part:", (pPart and pPart.Name) or "nil", "hit:", (hitPart and hitPart.Name) or "nil") )
						pcall(function()
							if Checkmark:IsA("ImageLabel") or Checkmark:IsA("ImageButton") then
								Checkmark.ImageColor3 = Color3.fromRGB(200, 0, 0)
								Checkmark.Visible = true
							end
						end)
					end
					lastAbleState = ableToPlace
				end

				task.wait()
			end
		end)

		Tool.Unequipped:Connect(function()
			isEquipped = false
			print("DEBUG: Tool unequipped:", Tool.Name)
			XYZGui.Enabled = false
			RotateUI.Enabled = false
			ForwardUI.Enabled = false
			BackwardUI.Enabled = false
			BuildPreview:ClearAllChildren()
			pcall(function() Checkmark.Visible = false end)
		end)

		Tool.Activated:Connect(function()
			if not isEquipped then
				print("DEBUG: Tried to activate while not equipped")
				return
			end

			print("DEBUG: Tool.Activated; ableToPlace:", ableToPlace)
			if not ableToPlace then
				print("DEBUG: placement blocked — cannot place here")
				-- optionally play error sound or flash UI
				return
			end

			-- Play place sound locally
			if PlaceSound then
				pcall(function() PlaceSound:Play() end)
			end

			-- Try firing server to place. Use pcall to catch errors if arguments aren't what server expects.
			local success, err = pcall(function()
				-- Most servers expect (cframe, buildName) but yours might expect a table or other args.
				-- This attempts the common form. Adjust if your remote expects different parameters.
				PlaceRemote:FireServer(BuildPreview.CFrame, Tool.Name)
			end)
			print("DEBUG: FireServer call returned:", success, err and tostring(err) or "no error")
			if not success then
				-- Try alternate form if the server expects a different payload
				local altSuccess, altErr = pcall(function()
					PlaceRemote:FireServer({CFrame = BuildPreview.CFrame, BuildName = Tool.Name})
				end)
				print("DEBUG: Alternate FireServer payload attempt:", altSuccess, altErr and tostring(altErr) or "no error")
			end
		end)
	end
	local function boot()
		init()
	end
	boot()
end
